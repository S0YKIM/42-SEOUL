⭐ ft_printf
============

- `va_start()`을 통해 `ap`가 첫번째 가변인자를 가리키게 한다.
- `result`에 `print_and_pars_args()` 로 출력된 바이트 수를 저장한다.
-  `va_end()`을 통해 `ap` 가 `NULL` 을 가리키게 한다.
-  최종적으로 읽었던 바이트 수인 `result`를 반환한다.

</br>
</br>

⭐ print_and_parse_flags
=======================

- `tag`에 `malloc`으로 메모리 할당
- `format[i] == %` 가 나오거나 문자열이 끝날 때까지 출력
- 만약에 `%`이 등장하면 `tag`을 초기화 한 뒤에 `csdiupxXo%` 가 나올 때까지 `store_flags()`을 통해 플래그 저장
- 그 다음에 오는 문자를 `tag->type`에 저장한 후에 `print_var_args()`로 넘어간다.

</br>
</br>

⭐ print_and_parse_flags
=======================

- `0` `-` `.` `+` ` ` `#` `숫자` 또는 `*` 에 해당하는 플래그를 `tag`의 요소에 저장한다.
- `숫자` 혹은 `*` 인 경우 `width` 또는 `precision` 두 가지 모두의 가능성이 있다.
- 이 경우 `store_width_and_prec()` 함수로 넘어간다.

</br>
</br>


⭐ print_var_args
================

- `tag->type` 이 `cspdiuxo%` 중에 무엇인지 검사하고
- `print_char()`, `print_string`, `print_number` 중에서 선택

- `tag->zero = 0` if 문에서 `0` 플래그를 끄는 경우?

</br>

1 - `tag->minus == 1`
---------------------

- 좌측 정렬인 경우에는 무조건 `0` 플래그가 무시된다

</br>

2 - `c`, `s`, `%` 을 제외한 `tag->precision > -1`
-----------------------------------------------

- 정밀도가 존재하는 경우에는 정밀도 옵션을 통해 `0` 을 채워주기 때문이다.
- 하지만 `c`, `s`, `%` 의 경우에는 정밀도가 `0`을 채우는 역할을 하는 것이 아니다.
- 정밀도는 무시되거나 문자열을 자르는 기능을 할 뿐, `0`플래그와 `width`가 존재할 때에 `0`이 채워진다.

      `c` 와  `%`: 정밀도 옵션이 완전히 무시된다.
      `s`: 정밀도 옵션이 문자열의 길이보다 작을 경우 잘라낸다. 

- ex) `printf("%010.3c\n", 'a');`     -> 000000000a 출력
- ex) `printf("%010.3%\n");`          -> 000000000% 출력
- ex) `printf("%010.3s\n", "abcde");` -> 0000000abc 출력 
